/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./js/audio.js":
/*!*********************!*\
  !*** ./js/audio.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _elm_web_audio_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./elm-web-audio.js */ \"./js/elm-web-audio.js\");\n\r\n\r\nexports.init = async function(app) {\r\n    const ctx = new AudioContext()\r\n    const virtualCtx = new _elm_web_audio_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](ctx)\r\n\r\n\r\n    app.ports.toWebAudio.subscribe((nodes) => {\r\n        virtualCtx.update(nodes)\r\n    })\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://lamderaproject0/./js/audio.js?");

/***/ }),

/***/ "./js/elm-web-audio.js":
/*!*****************************!*\
  !*** ./js/elm-web-audio.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ VirtualAudioGraph)\n/* harmony export */ });\n// To the poor soul that ends up reading or copying this, this is very old code.\r\n// It could be done much better but I don't have the time to rewrite it right\r\n// now. If you think you're up to the task, please considering submitting a PR\r\n// to improve it!\r\n\r\nconst defer = f => setTimeout(f, 0)\r\nconst AudioContext = window.AudioContext || window.webkitAudioContext\r\n\r\nclass VirtualAudioGraph {\r\n    // Static Methods ============================================================\r\n    //\r\n    static prepare(graph = []) {\r\n        // The first step in preparing the graph is to key each virtual node.\r\n        // This is how we perform a diff between graphs and calculate what has\r\n        // changed each update.\r\n        const key = (graph, base = '') => {\r\n            graph.forEach((node, i) => {\r\n                // RefNodes always have a key, and they also\r\n                // cannot have connections or properties\r\n                // so we can just return early and move on.\r\n                if (node.type === 'RefNode') return\r\n                // Assign the node a key if it didn't already have one.\r\n                // This is how we track changes to the graph in a slightly\r\n                // more organised way\r\n                if (!node.key) node.key = `${base}_${i}`\r\n\r\n                // Recursively assign keys to this nodes connections.\r\n                if (node.connections && node.connections.length > 0) {\r\n                    key(node.connections, node.key)\r\n                }\r\n            })\r\n\r\n            return graph\r\n        }\r\n\r\n        // It is often most natural to represent the audio graph as a list\r\n        // of trees, using RefNodes to \"jump\" between chains of node\r\n        // connections. This isns't the easiest data structure to deal with\r\n        // however, so the next step in preparation is the flatten the graph\r\n        // into a single array.\r\n        const flatten = (graph, nodes = {}, depth = 0) => {\r\n            graph.forEach((node, i) => {\r\n                // Don't push RefNodes to the flat graph.\r\n                if (node.type !== 'RefNode') nodes[node.key] = node\r\n                if (node.connections) flatten(node.connections, nodes, depth + 1)\r\n                // If we're deeper than the root of the graph, replace\r\n                // this node with a reference to itself by key.\r\n                if (depth > 0) graph[i] = { type: 'RefNode', key: node.key }\r\n            })\r\n\r\n            return nodes\r\n        }\r\n\r\n        return flatten(key(graph))\r\n    }\r\n\r\n    //\r\n    static diff(oldNodes, newNodes) {\r\n        const patches = { created: [], updated: [], removed: [] }\r\n\r\n        for (const newNode of Object.values(newNodes)) {\r\n            const oldNode = oldNodes[newNode.key]\r\n\r\n            // A node with newNode.key does not exist in the old graph, so this must\r\n            // mean we've created a brand new node.\r\n            if (!oldNode) {\r\n                patches.created.push({ type: 'node', key: newNode.key, data: newNode })\r\n\r\n                newNode.connections.forEach(connection => {\r\n                    patches.created.push({ type: 'connection', key: newNode.key, data: connection.key.split('.') })\r\n                })\r\n\r\n                // A node with the same key exists in both graphs, but the type has changed\r\n                // (eg osc -> gain) so we need to recreate the node.\r\n            } else if (oldNode.type !== newNode.type) {\r\n                patches.updated.push({ type: 'node', key: newNode.key, data: newNode })\r\n\r\n                newNode.connections.forEach(connection => {\r\n                    patches.created.push({ type: 'connection', key: newNode.key, data: connection.key.split('.') })\r\n                })\r\n\r\n                // A node with the same key exists in both graphs and the node hasn't\r\n                // fundamentally changed, so now we check whether properties or connections\r\n                // have changed.\r\n            } else {\r\n                // Checking properties...\r\n                for (let j = 0; j < Math.max(oldNode.properties.length, newNode.properties.length); j++) {\r\n                    const oldProp = oldNode.properties[j]\r\n                    const newProp = newNode.properties[j]\r\n\r\n                    //\r\n                    if (!oldProp) {\r\n                        patches.created.push({ type: 'property', key: oldNode.key, data: newProp })\r\n                    } else if (!newProp) {\r\n                        patches.removed.push({ type: 'property', key: oldNode.key, data: oldProp })\r\n                    } else if (oldProp.label !== newProp.label) {\r\n                        patches.removed.push({ type: 'property', key: oldNode.key, data: oldProp })\r\n                        patches.created.push({ type: 'property', key: oldNode.key, data: newProp })\r\n                    } else if (oldProp.value !== newProp.value) {\r\n                        patches.updated.push({ type: 'property', key: oldNode.key, data: newProp })\r\n                    }\r\n                }\r\n\r\n                // Checking connections...\r\n                for (let j = 0; j < Math.max(oldNode.connections.length, newNode.connections.length); j++) {\r\n                    const oldConnection = oldNode.connections[j]\r\n                    const newConnection = newNode.connections[j]\r\n\r\n                    //\r\n                    if (!oldConnection) {\r\n                        patches.created.push({ type: 'connection', key: oldNode.key, data: newConnection.key.split('.') })\r\n                    } else if (!newConnection) {\r\n                        patches.removed.push({ type: 'connection', key: oldNode.key, data: oldConnection.key.split('.') })\r\n                    } else if (oldConnection.key !== newConnection.key) {\r\n                        patches.removed.push({ type: 'connection', key: oldNode.key, data: oldConnection.key.split('.') })\r\n                        patches.created.push({ type: 'connection', key: oldNode.key, data: newConnection.key.split('.') })\r\n                    }\r\n                }\r\n            }\r\n\r\n            delete oldNodes[newNode.key]\r\n        }\r\n\r\n        for (const oldNode of Object.values(oldNodes)) {\r\n            patches.removed.push({ type: 'node', key: oldNode.key, data: oldNode })\r\n        }\r\n\r\n        return patches\r\n    }\r\n\r\n    // Constructor ===============================================================\r\n    //\r\n    constructor(context = new AudioContext(), opts = {}) {\r\n        // Borrowing a convetion from virtual dom libraries, the $ sign //is used to\r\n        // indicate \"real\" Web Audio bits, and the v- prefix is used to indicate\r\n        // virtual elements.\r\n\r\n        // $context is a reference to the `AudioContext` either passed in or created\r\n        // on construction.\r\n        this.$context = context\r\n        // A reference to the real graph of audio nodes\r\n        this.$nodes = {}\r\n        // We keep track of the prebious graph so we can perform a diff and work out\r\n        // what has changed between updates.\r\n        this.vPrev = {}\r\n\r\n        // In most modern browsers an Audio Context starts in a suspended state and\r\n        // requires some user interaction before it can be resumed. Still, we can\r\n        // attempt to resume the context ourselves in the developer passes in the\r\n        // `autostart` option.\r\n        if (opts.autostart) this.resume()\r\n    }\r\n\r\n    // Public Methods ============================================================\r\n    //\r\n    update(vGraph = []) {\r\n        // The accompanying library of virtual node functions\r\n        // encourages a nested tree-like approach to describing\r\n        // audio graphs. This isn't the easiest structure to deal\r\n        // with, however, so a preparation step serves to wrestle\r\n        // the graph into a more suitable shape.\r\n        const vCurr = VirtualAudioGraph.prepare(vGraph)\r\n\r\n        // A diff tracks everything that has been removed, created,\r\n        // and updated between updates. We perform this step so we\r\n        // only touch the audio nodes that need to be changed in some\r\n        // way.\r\n        const diff = VirtualAudioGraph.diff(this.vPrev, vCurr)\r\n\r\n        // Remove nodes and properties from the graph.\r\n        diff.removed.forEach(patch => {\r\n            switch (patch.type) {\r\n                case 'node':\r\n                    this._destroyNode(patch.key)\r\n                    break\r\n                case 'property':\r\n                    this._removeProperty(patch.key, patch.data)\r\n                    break\r\n                case 'connection':\r\n                    this._disconnect(patch.key, patch.data)\r\n                    break\r\n            }\r\n        })\r\n\r\n        // Create new nodes and add new properties to\r\n        // the graph.\r\n        diff.created.forEach(patch => {\r\n            switch (patch.type) {\r\n                case 'node':\r\n                    this._createNode(patch.key, patch.data)\r\n                    break\r\n                case 'property':\r\n                    this._setProperty(patch.key, patch.data)\r\n                    break\r\n                case 'connection':\r\n                    defer(() => this._connect(patch.key, patch.data))\r\n                    break\r\n            }\r\n        })\r\n\r\n        // Update existing nodes and properties in the\r\n        // graph.\r\n        diff.updated.forEach(patch => {\r\n            switch (patch.type) {\r\n                case 'node':\r\n                    this._destroyNode(patch.key)\r\n                    this._createNode(patch.key, patch.data)\r\n                    break\r\n                case 'property':\r\n                    this._setProperty(patch.key, patch.data)\r\n                    break\r\n                case 'connection':\r\n                    // Connections can't be updated\r\n                    break\r\n            }\r\n        })\r\n\r\n        // Store the current graph for next time.\r\n        this.vPrev = vCurr\r\n    }\r\n\r\n    // A thin wrapper of the `AudioContext.suspend()` method. This\r\n    // bassically exists so developers don't have to reach in and\r\n    // touch the \"real\" audio context directly.\r\n    suspend() {\r\n        this.$context.suspend()\r\n    }\r\n\r\n    // A thin wrapper of the `AudioContext.resume()` method. This\r\n    // bassically exists so developers don't have to reach in and\r\n    // touch the \"real\" audio context directly.\r\n    resume() {\r\n        this.$context.resume()\r\n    }\r\n\r\n    // Private Methods ===========================================================\r\n    //\r\n    _createNode(key, { type, properties }) {\r\n        let $node = null\r\n\r\n        //\r\n        switch (type) {\r\n            case 'AnalyserNode':\r\n                $node = this.$context.createAnalyser()\r\n                break\r\n            case 'AudioBufferSourceNode':\r\n                $node = this.$context.createBufferSource()\r\n                break\r\n            case 'AudioDestinationNode':\r\n                $node = this.$context.destination\r\n                break\r\n            case 'BiquadFilterNode':\r\n                $node = this.$context.createBiquadFilter()\r\n                break\r\n            case 'ChannelMergerNode':\r\n                $node = this.$context.createChannelMerger()\r\n                break\r\n            case 'ChannelSplitterNode':\r\n                $node = this.$context.createChannelSplitter()\r\n                break\r\n            case 'ConstantSourceNode':\r\n                $node = this.$context.createConstantSource()\r\n                break\r\n            case 'ConvolverNode':\r\n                $node = this.$context.createConvolver()\r\n                break\r\n            case 'DelayNode':\r\n                const maxDelayTime = properties.find(({ label }) => label === 'maxDelayTime')\r\n                $node = this.$context.createDelay((maxDelayTime && maxDelayTime.value) || 1)\r\n                break\r\n            case 'DynamicsCompressorNode':\r\n                $node = this.$context.createDynamicsCompressor()\r\n                break\r\n            case 'GainNode':\r\n                $node = this.$context.createGain()\r\n                break\r\n            case 'IIRFilterNode':\r\n                const feedforward = properties.find(({ label }) => label === 'feedforward')\r\n                const feedback = properties.find(({ label }) => label === 'feedback')\r\n                $node = this.$context.createIIRFilter(\r\n                    (feedforward && feedforward.value) || [0],\r\n                    (feedback && feedback.value) || [1]\r\n                )\r\n                break\r\n            case 'MediaElementAudioSourceNode':\r\n                const mediaElement = properties.find(({ label }) => label === 'mediaElement')\r\n                $node = this.$context.createMediaElementSource(\r\n                    document.querySelector(mediaElement.value)\r\n                )\r\n                break\r\n            case 'MediaStreamAudioDestinationNode':\r\n                $node = this.$context.createMediaStreamDestination()\r\n                break\r\n            // TODO: How should I handle creating / grabbing the media stream?\r\n            // case 'MediaStreamAudioSourceNode':\r\n            //   $node = this.$context.createMediaStreamSource(\r\n\r\n            //   )\r\n            //   break\r\n            case 'OscillatorNode':\r\n                $node = this.$context.createOscillator()\r\n                break\r\n            case 'PannerNode':\r\n                $node = this.$context.createPanner()\r\n                break\r\n            case 'StereoPannerNode':\r\n                $node = this.$context.createStereoPanner()\r\n                break\r\n            case 'WaveShaperNode':\r\n                $node = this.$context.createWaveShaper()\r\n                break\r\n            //\r\n            default:\r\n                console.warn(`Invalide node type of: ${type}. Defaulting to GainNode to avoid crashing the AudioContext.`)\r\n                $node = this.$context.createGain()\r\n        }\r\n\r\n        this.$nodes[key] = $node\r\n\r\n        //\r\n        properties.forEach(prop => this._setProperty(key, prop))\r\n\r\n        // Certain nodes like oscillators must be started before they will produce\r\n        // noise. We make the assumption that these nodes should always start\r\n        // immediately after they have been created, so if a `start` method exists we\r\n        // call it.\r\n        if ($node.start) $node.start()\r\n    }\r\n\r\n    //\r\n    _destroyNode(key) {\r\n        const $node = this.$nodes[key]\r\n\r\n        // Certain nodes like oscillators can be stopped. It probably doesn't make\r\n        // much of a difference calling this method, but we do just in case!\r\n        if ($node.stop) $node.stop()\r\n\r\n        // Calling disconnect with no arguments will disconnect this node from\r\n        // everything.\r\n        $node.disconnect()\r\n\r\n        // Finally remove the node from the graph and let the GC do its job.\r\n        delete this.$nodes[key]\r\n    }\r\n\r\n    //\r\n    _setProperty(key, { type, label, value }) {\r\n        const $node = this.$nodes[key]\r\n\r\n        switch (type) {\r\n            case 'NodeProperty':\r\n                $node[label] = value\r\n                break\r\n            case 'AudioParam':\r\n                $node[label].linearRampToValueAtTime(value, this.$context.currentTime + 0.01)\r\n                break\r\n            case 'ScheduledUpdate':\r\n                $node[label][value.method](value.target, value.time)\r\n                break\r\n        }\r\n    }\r\n\r\n    //\r\n    _removeProperty(key, { type, label, value }) {\r\n        const $node = this.$nodes[key]\r\n\r\n        switch (type) {\r\n            case 'NodeProperty':\r\n                break\r\n            case 'AudioParam':\r\n                $node[label].value = $node[label].default\r\n                break\r\n            case 'ScheduledUpdate':\r\n                // TODO: work out how to cancel scheduled updates\r\n                break\r\n        }\r\n    }\r\n\r\n    //\r\n    _connect(a, [b, param = null]) {\r\n        if (b) this.$nodes[a].connect(param ? this.$nodes[b][param] : this.$nodes[b])\r\n    }\r\n\r\n    //\r\n    _disconnect(a, [b, param = null]) {\r\n        if (b) this.$nodes[a].disconnect(param ? this.$nodes[b][param] : this.$nodes[b])\r\n    }\r\n}\n\n//# sourceURL=webpack://lamderaproject0/./js/elm-web-audio.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./js/audio.js");
/******/ 	
/******/ })()
;